# Technical Debt Management

Best practices for identifying, categorizing, tracking, and systematically paying down technical debt — including debt generated by AI-assisted development.

> **Scope**: Covers technical debt as a managed engineering concern: classification, measurement, prioritization, and paydown strategies. Applies to any team balancing feature velocity with codebase health.

## Contents

| Section |
| :--- |
| [Quick Reference](#quick-reference) |
| [Core Principles](#core-principles) |
| [Identification and Categorization](#identification-and-categorization) |
| [Measurement and Prioritization](#measurement-and-prioritization) |
| [Tracking](#tracking) |
| [Paydown Strategies](#paydown-strategies) |
| [Prevention](#prevention) |
| [Anti-Patterns](#anti-patterns) |
| [Red Flags](#red-flags) |
| [Checklist](#checklist) |
| [See Also](#see-also) |

---

## Quick Reference

**Debt categories**:

| Category | Description | Example |
| :--- | :--- | :--- |
| **Code debt** | Duplication, poor naming, tangled logic | Copy-pasted retry logic across handlers |
| **Architecture debt** | Wrong abstractions, tight coupling | Monolith that should be split; shared DB between services |
| **Test debt** | Missing coverage, flaky tests, slow suites | Critical payment path has zero integration tests |
| **Documentation debt** | Stale docs, missing runbooks | API docs describe v1 while v3 is deployed |
| **Dependency debt** | Outdated libraries, unmaintained packages | Running 3 major versions behind on framework |

**Key rules**:

- Track it or it compounds — untracked debt grows silently until it blocks feature work
- Prioritize by cost of delay — fix what gets more expensive to ignore, not what annoys you most

---

## Core Principles

1. **Debt is a decision, not an accident** — Intentional debt (shipping fast with known shortcuts) is a valid business choice when documented and tracked. Accidental debt (sloppy code nobody noticed) is a process failure. Label which is which so you can manage both differently.
2. **Track or it compounds** — Debt that exists only in developers' heads grows silently. Every known shortcut gets a ticket or it never gets fixed. Untracked debt is invisible debt, and invisible debt compounds without limit.
3. **Prioritize by cost of delay** — The question is not "how annoying is this?" but "how much more expensive does this get every week we ignore it?" Fix what compounds fastest, not what frustrates loudest.
4. **AI accelerates debt creation** — AI-generated code ships faster, which means inconsistent patterns, mismatched error handling, and undocumented assumptions accumulate faster. Review AI output with the same rigor as any other code. Speed without consistency is just faster debt creation.
5. **Prevention beats paydown** — Catching debt at PR review costs minutes. Paying it down six months later costs days. Invest in review gates and static analysis that prevent debt from merging in the first place.

---

## Identification and Categorization

### Debt Categories

| Category | Symptoms | Typical Sources |
| :--- | :--- | :--- |
| **Code debt** | Duplication, long methods, poor naming | Time pressure, copy-paste, AI-generated boilerplate |
| **Architecture debt** | Tight coupling, wrong boundaries, scaling walls | Early design decisions that outlived their context |
| **Test debt** | Low coverage, flaky tests, missing integration tests | "We'll add tests later" during a deadline push |
| **Documentation debt** | Stale READMEs, missing runbooks, undocumented APIs | Docs not updated alongside code changes |
| **Dependency debt** | Outdated packages, known CVEs, abandoned libraries | Skipped upgrade cycles, transitive dependency rot |

### Detection Signals

| Debt Type | Detection Signal |
| :--- | :--- |
| Code debt | Cyclomatic complexity above threshold; duplicated blocks flagged by linter |
| Architecture debt | Circular dependencies; changes to one module require changes in three others |
| Test debt | Coverage below target; flaky test rate above 5%; no tests for critical paths |
| Documentation debt | Support tickets answered by "that doc is outdated"; onboarding takes 2x longer than expected |
| Dependency debt | `npm audit` / `pip audit` returning high/critical findings; major version drift > 2 |

### AI-Generated Debt

AI tools produce code fast but often introduce subtle inconsistencies.

| Pattern | Description | Risk |
| :--- | :--- | :--- |
| **Works-but-isn't-right** | Code passes tests but uses wrong abstractions or ignores project conventions | Compounds when others copy the AI-established pattern |
| **Over-abstraction** | AI produces generalized solutions for specific problems | Unnecessary complexity; harder to maintain |
| **Inconsistent error handling** | Each AI-generated function handles errors differently | Bugs from inconsistent behavior; harder to reason about failure modes |
| **Missing context** | AI lacks awareness of existing utilities, duplicates them | Codebase bloat; divergent implementations of the same concern |

```python
# Bad: AI-generated code accepted without review
def create_user(data):
    try:
        user = db.insert("users", data)
        return user
    except Exception as e:
        print(f"Error: {e}")
        return None

def create_order(data):
    result = db.insert("orders", data)
    if not result:
        raise ValueError("Failed to create order")
    return result
```

```python
# Good: AI output reviewed and normalized
def create_user(data: UserCreate) -> User:
    try:
        return db.insert("users", data)
    except DatabaseError as e:
        raise ServiceError("user_creation_failed", cause=e)

def create_order(data: OrderCreate) -> Order:
    try:
        return db.insert("orders", data)
    except DatabaseError as e:
        raise ServiceError("order_creation_failed", cause=e)
```

---

## Measurement and Prioritization

### Impact-Effort Matrix

Use a 2x2 matrix to sequence paydown work. Start top-left, avoid bottom-right.

| | Low Effort | High Effort |
| :--- | :--- | :--- |
| **High Impact** | Do first — quick wins that remove real pain | Schedule — worth the investment, plan a spike |
| **Low Impact** | Do opportunistically — fix during nearby work | Skip or defer — cost of fix exceeds cost of debt |

### Cost of Delay

Estimate cost of delay by answering three questions:

| Question | Metric |
| :--- | :--- |
| How often does this debt cause extra work? | Incidents/week, duplicated changes/month |
| Does the cost grow over time? | Each new feature copies the bad pattern? Each sprint loses more velocity? |
| What is the blast radius of failure? | One team, one service, or customer-facing outage? |

Multiply frequency by growth rate by blast radius for a rough priority score. Exact numbers matter less than consistent ranking across your backlog. Re-score quarterly as conditions change.

```yaml
# Bad: prioritizing by annoyance
debt_backlog:
  - item: "Rename variable 'x' to 'count' in utils.py"
    priority: P1   # Developer pet peeve, zero user impact
  - item: "Payment retry logic duplicated in 3 handlers"
    priority: P3   # Annoying but "works fine"
```

```yaml
# Good: prioritizing by cost of delay
debt_backlog:
  - item: "Payment retry logic duplicated in 3 handlers"
    priority: P1   # Each new handler copies the bug; incident last month
    cost_of_delay: "High — grows with every new payment method"
  - item: "Rename variable 'x' to 'count' in utils.py"
    priority: P3   # Low impact, fix during nearby work
    cost_of_delay: "None — cosmetic only"
```

---

## Tracking

### Debt Inventory

Use a consistent ticket template so debt items are actionable, not vague wishes.

```markdown
## TECH-DEBT: [Short description of the debt]

- **Category**: [Code | Architecture | Test | Documentation | Dependency]
- **Impact**: [High | Medium | Low] — [one-line explanation]
- **Effort**: [High | Medium | Low] — [rough estimate]
- **Cost of delay**: [What gets worse if we wait?]
- **Introduced**: [Date or PR where debt was created]
- **Owner**: [Team or person responsible for the area]
- **Definition of done**: [Concrete exit criteria]
```

### Issue Tracker Integration

| Label | Purpose |
| :--- | :--- |
| `tech-debt` | Primary label for all debt items |
| `debt:code` / `debt:arch` / `debt:test` / `debt:doc` / `debt:dep` | Category sub-labels |
| `impact:high` / `impact:medium` / `impact:low` | Priority filtering |
| `effort:low` | Quick wins filter for opportunistic paydown |
| `ai-generated` | Debt introduced by AI-assisted development |

```markdown
<!-- Bad: vague debt tracking -->
TODO: fix this later
TODO: refactor
TODO: clean up
```

```markdown
<!-- Good: actionable debt ticket -->
## TECH-DEBT: Payment service retry logic duplicated across 3 handlers
- **Category**: Code debt (duplication)
- **Impact**: High — changes require updating 3 places; bugs from inconsistency
- **Effort**: Low — extract shared retry utility (~2 hours)
- **Cost of delay**: Each new payment handler copies the pattern again
- **Definition of done**: Single retry utility used by all payment handlers; old code removed
```

---

## Paydown Strategies

### Dedicated Sprints vs Continuous

| Strategy | Pros | Cons | Best For |
| :--- | :--- | :--- | :--- |
| **Dedicated debt sprint** | Focused attention; visible progress | Gets deprioritized; "next sprint" never comes | Large architecture debt requiring sustained focus |
| **Continuous allocation (20%)** | Steady progress; never falls off radar | Slower for big items; requires discipline | Code debt, test debt, dependency updates |
| **Boy Scout rule** | Zero overhead; opportunistic | Only addresses debt near active work | Small code debt, naming, minor duplication |
| **Debt budget per feature** | Ties paydown to new work; prevents growth | May not address legacy areas | Teams adding features to debt-heavy areas |

### Refactoring with AI

AI agents are effective for systematic, repetitive refactoring when given clear patterns. The key is providing enough context to prevent the AI from introducing new debt while paying down old debt.

| Task | AI Suitability | Guidance Needed |
| :--- | :--- | :--- |
| Extracting duplicated code into shared utilities | High | Provide the target interface; review output for consistency |
| Migrating API call patterns | High | Supply before/after examples; validate error handling |
| Adding missing type annotations | High | Specify type conventions; review edge cases |
| Standardizing error handling across modules | High | Provide the canonical error pattern; verify all paths covered |
| Redesigning module boundaries | Low | Architecture decisions require human judgment |
| Updating deprecated API usage | Medium | Provide migration guide; verify behavioral equivalence |

When using AI for debt paydown, always:

- Provide the existing project patterns as context (link to AGENTS.md or style guide)
- Review output for consistency with the rest of the codebase, not just correctness
- Run the full test suite after AI-generated refactors — behavioral regressions hide in edge cases

```yaml
# Bad: "debt sprint" that never gets scheduled
sprint_12:
  planned: "Tech debt sprint"
  actual: "Urgent feature request from sales"
sprint_15:
  planned: "Tech debt sprint (rescheduled)"
  actual: "Another urgent feature"
# Result: zero debt paid down in 6 months
```

```yaml
# Good: 20% continuous allocation enforced by process
sprint_12:
  capacity: 40 story points
  feature_work: 32 points
  debt_paydown: 8 points  # protected, non-negotiable
  debt_items_completed:
    - "Extract shared retry utility (3 pts)"
    - "Add integration tests for payment flow (5 pts)"
```

---

## Prevention

### Code Review Gates

Check these during every PR review to prevent new debt from merging.

| Gate | Check |
| :--- | :--- |
| Pattern consistency | Does new code follow established project patterns? |
| Error handling | Does it match the project's error handling strategy? |
| Test coverage | Are new paths tested? Does coverage meet the threshold? |
| Duplication | Does this duplicate existing utilities or modules? |
| Dependency justification | Is a new dependency necessary? Is it maintained? |
| AI output review | Was AI-generated code reviewed for project convention compliance? |
| Documentation | Are affected docs updated alongside the code change? |

### Static Analysis Integration

Configure CI gates that catch new debt before it merges. The goal is not zero warnings — it is preventing new debt from entering while you pay down existing debt.

| Tool Category | What It Catches | Threshold Example |
| :--- | :--- | :--- |
| Complexity checker | Functions too complex to maintain | Cyclomatic complexity <= 15 per function |
| Coverage gate | Missing tests for new code | New code coverage >= 80% |
| Duplication detector | Copy-pasted blocks | Zero new duplicated blocks > 6 lines |
| Dependency scanner | Known vulnerabilities, outdated packages | Zero high/critical CVEs |
| Linter rules | Style drift, deprecated patterns | Zero linter warnings in changed files |

```yaml
# Example: CI gate configuration for debt prevention
quality_gates:
  complexity:
    max_cyclomatic: 15
    fail_on: new_violations  # only fail on new code, not legacy
  coverage:
    minimum: 80
    scope: changed_files      # enforce on touched code
  duplication:
    min_block_size: 6
    max_duplicates: 0
  dependencies:
    max_critical_cves: 0
    max_major_version_drift: 2
```

---

## Anti-Patterns

| Anti-Pattern | Problem | Fix |
| :--- | :--- | :--- |
| **Debt amnesty** | Declaring "bankruptcy" and deleting the backlog feels good but discards triage work | Archive old items; re-triage the top 20 instead of wiping the slate |
| **Backlog graveyard** | Debt tickets filed and never revisited; backlog grows to 500+ items | Review debt backlog monthly; close items that are no longer relevant |
| **Gold-plating as paydown** | Rewriting working code to be "elegant" without measurable benefit | Require cost-of-delay justification for every debt ticket |
| **Ignoring AI-generated debt** | Treating AI output as vetted because "it works" | Apply the same review standards to AI code as human code |
| **Debt without definition of done** | Tickets say "refactor X" with no exit criteria | Every debt ticket needs a concrete definition of done |
| **Measuring debt by count** | Tracking number of debt items instead of impact | Measure by cost of delay, incident frequency, or velocity drag |

---

## Red Flags

| Signal | Action | Rationale |
| :--- | :--- | :--- |
| Velocity declining with stable scope | Audit for hidden debt drag; check if features take longer due to workarounds | Untracked debt is silently taxing every feature |
| Zero tracked debt items | Start tracking — zero means you are not looking, not that debt is absent | Every codebase has debt; zero items means broken detection |
| AI code accepted without modification | Tighten review process; add AI-output review to PR checklist | Unreviewed AI code is the fastest path to inconsistent patterns |
| Debt items with no definition of done | Add exit criteria to every open debt ticket | Vague tickets never get completed; they just age |
| Same area causing repeated incidents | Prioritize that area for debt paydown immediately | Recurring incidents signal compounding debt |
| New hires take >2x expected onboarding time | Audit documentation debt and codebase clarity | Onboarding friction is a proxy for undocumented complexity |

---

## Checklist

- [ ] All known technical debt is tracked in the issue tracker with the `tech-debt` label
- [ ] Each debt item has a category, impact rating, and definition of done
- [ ] Debt backlog is reviewed at least monthly; stale items are closed or re-triaged
- [ ] Team allocates a protected percentage of capacity (e.g., 20%) to debt paydown
- [ ] CI gates enforce complexity, coverage, and duplication thresholds on new code
- [ ] PR review checklist includes pattern consistency and AI-output review
- [ ] Dependency updates are scheduled at a regular cadence (e.g., monthly)
- [ ] Cost of delay is estimated for high-impact debt items
- [ ] Debt metrics (count by category, age, velocity impact) are visible to the team
- [ ] AI-generated code is reviewed for project convention compliance before merge

---

## See Also

- [Static Analysis](../static-analysis/static-analysis.md) — Automated detection of code-level debt
- [Coding Guidelines](../coding-guidelines/coding-guidelines.md) — Standards that prevent code debt
- [Planning Documentation](../planning-documentation/planning-documentation.md) — Roadmaps and ADRs for architecture decisions
- [Documentation Maintenance](../doc-maintenance/doc-maintenance.md) — Keeping docs in sync with code changes
- [Code Review for AI Output](../code-review-ai/code-review-ai.md) — Review standards for AI-generated code
